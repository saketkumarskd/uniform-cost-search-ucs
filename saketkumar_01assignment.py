# -*- coding: utf-8 -*-
"""SaketKumar_01Assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rfk3Z17WWsy7mmX8WhpCHYo42XkwIOzX

# **NAME- SAKET KUMAR**
#**ROLL NO.- 2312res560**
#**COLLEGE NAME- INDIAN INSTITUTE OF TECHNOLOGY, PATNA**
#**BRANCH- BSc(CSDA)**
#**SUBJECT- BO CDA 305: Artificial Intelligence Techniques**
#**Assignment - 01**
#**SEMESTER- 05**
#**YEAR- 03**
---

### **Problem Statement :**
*The task is to check if we can reach from any random start grid to the mentioned target grid by moving the Blank space ('B').*

- In one step, the Blank space can move **Top / Down / Left / Right**.
- Input: Random 3x3 grid containing numbers 1 to 8 and one Blank (B).
- Target grid is fixed:

- Implement using **BFS and DFS**.
- Compare number of steps required and comment which algorithm is faster and why.

# **Import Libraries**
"""

import random
from collections import deque

"""# **Helper Functions**"""

# Generate a random 3x3 puzzle state
def generate_random_puzzle():
    elements = [str(i) for i in range(1, 9)] + ['B']
    random.shuffle(elements)
    return [elements[i:i+3] for i in range(0, 9, 3)]

# Convert grid to string (for hashing / visited check)
def grid_to_str(grid):
    return ''.join(sum(grid, []))

# Find blank position
def find_blank(grid):
    for i in range(3):
        for j in range(3):
            if grid[i][j] == 'B':
                return i, j
    return None

# Move blank (generate next states)
def get_neighbors(grid):
    x, y = find_blank(grid)
    moves = [(0,1),(0,-1),(1,0),(-1,0)]
    neighbors = []

    for dx, dy in moves:
        nx, ny = x+dx, y+dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_grid = [row[:] for row in grid]
            new_grid[x][y], new_grid[nx][ny] = new_grid[nx][ny], new_grid[x][y]
            neighbors.append(new_grid)
    return neighbors

"""# **BFS Implementation**"""

def bfs(start, target):
    start_str = grid_to_str(start)
    target_str = grid_to_str(target)

    visited = set([start_str])
    queue = deque([(start, 0)])

    while queue:
        state, depth = queue.popleft()

        if grid_to_str(state) == target_str:
            return depth

        for neighbor in get_neighbors(state):
            state_str = grid_to_str(neighbor)
            if state_str not in visited:
                visited.add(state_str)
                queue.append((neighbor, depth+1))
    return -1

"""# **DFS Implementation**"""

def dfs(start, target, max_depth=50):
    start_str = grid_to_str(start)
    target_str = grid_to_str(target)

    visited = set()

    def recursive_dfs(state, depth):
        if depth > max_depth:
            return -1
        if grid_to_str(state) == target_str:
            return depth
        visited.add(grid_to_str(state))

        for neighbor in get_neighbors(state):
            state_str = grid_to_str(neighbor)
            if state_str not in visited:
                result = recursive_dfs(neighbor, depth+1)
                if result != -1:
                    return result
        return -1

    return recursive_dfs(start, 0)

"""# **Run Example**"""

# Generate random start grid
start_grid = generate_random_puzzle()
target_grid = [['1','2','3'],['4','5','6'],['7','8','B']]

print("Start Grid:")
for row in start_grid:
    print(row)

print("\nTarget Grid:")
for row in target_grid:
    print(row)

# BFS
steps_bfs = bfs(start_grid, target_grid)
print("\nBFS Steps to reach target:", steps_bfs)

# DFS
steps_dfs = dfs(start_grid, target_grid)
print("DFS Steps to reach target (if found within depth limit):", steps_dfs)

"""# **Explanation & Comparison**

### **Comparison of BFS and DFS**

*When solving search problems such as the 8-puzzle, two very common strategies are Breadth First Search (BFS) and Depth First Search (DFS). Both are systematic approaches, but they behave very differently in terms of path finding, memory usage, and efficiency.*



---

## **üîπ Comparison of BFS and DFS**

When solving search problems such as the **8-puzzle**, two very common strategies are **Breadth First Search (BFS)** and **Depth First Search (DFS)**. Both are systematic approaches, but they behave very differently in terms of path finding, memory usage, and efficiency.

---

### **‚úîÔ∏è Breadth First Search (BFS)**

1. **Shortest Path Guarantee**
   BFS always expands nodes **level by level** starting from the root. This means that once a solution is found, it is guaranteed to be the one requiring the **minimum number of moves**. For example, if the goal state can be reached in just 4 moves, BFS will find that exact path instead of a longer one.

2. **Exploration Strategy**
   BFS begins at the root node and explores all the direct children before moving deeper. After covering all nodes at depth 1, it goes to depth 2, then depth 3, and so on.

3. **Memory Requirement**
   The major drawback of BFS is its memory consumption. Since it needs to store all nodes at the current frontier before moving deeper, the memory grows very quickly, especially in large problems.

4. **Optimality**
   The biggest strength of BFS is **optimality** ‚Äì it ensures that the solution found is always the shortest in terms of steps taken.

---

### **‚úîÔ∏è Depth First Search (DFS)**

1. **Exploration Strategy**
   DFS follows a completely different approach. It goes **as deep as possible along one branch** before backtracking. In other words, it tries to reach the solution by fully exploring one path first, and if it fails, it backtracks to try alternative branches.

2. **Optimality**
   Unlike BFS, DFS is **not guaranteed to find the shortest path**. It may reach a solution faster in some cases, but that solution could be much longer than necessary.

3. **Risk of Getting Stuck**
   DFS can sometimes get ‚Äúlost‚Äù in very deep branches that do not lead to the solution, especially if a depth limit is not applied. If the solution is shallow but DFS first explores a deep wrong branch, it will waste time unnecessarily.

4. **Memory Requirement**
   The advantage of DFS is its low memory consumption. Since it only needs to store the current path and a few alternatives, its space complexity is much smaller compared to BFS.

---

### **‚úîÔ∏è Intuition with Example**

* Imagine searching for a **lost item** in a building:

  * **BFS** is like searching floor by floor, making sure every room on one floor is checked before moving to the next. This way, you will find the closest item first, ensuring you do not miss a quicker solution.
  * **DFS** is like picking one staircase, going all the way down without checking other floors, hoping the item is there. You might get lucky and find it deep inside, but you might also waste a lot of time if it isn‚Äôt there.

---

### **‚úîÔ∏è Application to the 8-Puzzle**

* If the solution is only a **few moves away from the starting configuration**, BFS is the best choice because it will find the shortest solution quickly.
* If the solution requires exploring **deep sequences of moves**, DFS might stumble upon it sooner, but there is no guarantee that the solution will be optimal.
* Therefore, in practice, for problems like the **8-puzzle**, BFS is generally preferred because **correctness and optimality** are more important than saving memory.

---

**üîπ Final Note :**

* **BFS** ‚Üí More memory, slower sometimes, but always gives the shortest path.
* **DFS** ‚Üí Less memory, sometimes faster, but not always reliable for optimal solutions.
"""